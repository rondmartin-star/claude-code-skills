# Security Patterns Reference

Detailed security implementation patterns for Windows applications with FastAPI/Flask backends.

---

## 1. Route Authentication Patterns

### FastAPI with Manual Auth Check

```python
from fastapi import Request, HTTPException
from fastapi.responses import RedirectResponse

@router.get("/admin/dashboard")
async def admin_dashboard(request: Request, db: Session = Depends(get_db)):
    # 1. Get current user (returns None if not authenticated)
    current_user = get_current_user(request, db)

    # 2. Redirect to login if not authenticated
    if not current_user:
        return RedirectResponse(
            url=f"/login?next={request.url.path}",
            status_code=303
        )

    # 3. Check role if needed
    if current_user.role not in [UserRole.MANAGER, UserRole.ADMIN]:
        raise HTTPException(status_code=403, detail="Insufficient permissions")

    # 4. Now safe to render
    return templates.TemplateResponse(
        "admin/dashboard.html",
        {"request": request, "current_user": current_user}
    )
```

### FastAPI with Dependency Injection

```python
from fastapi import Depends, HTTPException, status

def get_current_active_user(
    request: Request,
    db: Session = Depends(get_db)
) -> User:
    user = get_current_user(request, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Inactive user"
        )
    return user

def require_admin(user: User = Depends(get_current_active_user)) -> User:
    if user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    return user

# Usage
@router.post("/admin/users", dependencies=[Depends(require_admin)])
async def create_user(...):
    ...
```

### Public vs Protected Routes

```python
# PUBLIC - No auth required
PUBLIC_ROUTES = [
    "/",
    "/login",
    "/auth/google",
    "/auth/google/callback",
    "/requests/new",      # Public can submit requests
    "/requests/status",   # Public can check status
    "/venues",            # Public can browse venues
    "/help",              # Public help center
]

# PROTECTED - Auth required
# All routes under /admin/* require authentication

# ROLE-SPECIFIC
ADMIN_ONLY = ["/admin/users", "/admin/settings"]
MANAGER_PLUS = ["/admin/requests/approve", "/admin/bookings/approve"]
```

---

## 2. Template Escaping Patterns

### Auto-Escaping (Default - Safe)

```html
<!-- These are automatically escaped -->
{{ user.name }}                    <!-- <script> becomes &lt;script&gt; -->
{{ request.description }}          <!-- Safe for user content -->
{{ comment.text }}                 <!-- Safe for user content -->

<!-- In attributes - also escaped -->
<input value="{{ user.email }}">   <!-- Safe -->
<a href="/user/{{ user.id }}">     <!-- Safe for IDs -->
```

### The |safe Filter (Use With Extreme Caution)

```html
<!-- DANGEROUS - Never on user content -->
{{ user.bio|safe }}                <!-- User could inject <script> -->
{{ article.body|safe }}            <!-- If users can edit articles -->

<!-- ACCEPTABLE - Server-generated content -->
{{ pagination_html|safe }}         <!-- Generated by server -->
{{ breadcrumb_html|safe }}         <!-- Generated by server -->
{{ icon_svg|safe }}                <!-- Static SVG from server -->

<!-- ACCEPTABLE - After sanitization -->
{% set clean = content|sanitize_html %}
{{ clean|safe }}                   <!-- Sanitized first -->
```

### HTML Sanitization Pattern

```python
# Using bleach library
import bleach

ALLOWED_TAGS = ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li', 'a']
ALLOWED_ATTRS = {'a': ['href', 'title']}

def sanitize_html(content: str) -> str:
    return bleach.clean(
        content,
        tags=ALLOWED_TAGS,
        attributes=ALLOWED_ATTRS,
        strip=True
    )

# Register as Jinja2 filter
templates.env.filters['sanitize_html'] = sanitize_html
```

### JavaScript Context

```html
<!-- WRONG - XSS via JavaScript -->
<script>
    var userName = "{{ user.name }}";  <!-- Breaks if name contains " or \n -->
</script>

<!-- CORRECT - Use tojson filter -->
<script>
    var userName = {{ user.name|tojson }};  <!-- Properly escaped for JS -->
    var userData = {{ user_dict|tojson }};  <!-- For objects -->
</script>
```

---

## 3. Form Security Patterns

### Standard POST Form

```html
<form method="post" action="{{ url_for('module.action') }}">
    <!-- CSRF Token - ALWAYS FIRST -->
    <input type="hidden" name="csrf_token" value="{{ csrf_token }}">

    <!-- Fields with validation -->
    <div class="mb-3">
        <label for="email">Email</label>
        <input type="email"
               id="email"
               name="email"
               required
               maxlength="255"
               pattern="[^@]+@[^@]+\.[^@]+">
    </div>

    <button type="submit">Submit</button>
</form>
```

### File Upload Form

```html
<form method="post"
      action="{{ url_for('module.upload') }}"
      enctype="multipart/form-data">

    <input type="hidden" name="csrf_token" value="{{ csrf_token }}">

    <div class="mb-3">
        <label for="document">Document</label>
        <input type="file"
               id="document"
               name="document"
               accept=".pdf,.doc,.docx,.jpg,.jpeg,.png"
               required>
        <small class="text-muted">
            Accepted: PDF, Word, Images. Max 10MB.
        </small>
    </div>

    <button type="submit">Upload</button>
</form>
```

### AJAX Form Submission

```html
<form id="ajax-form">
    <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
    <input type="text" name="title" required>
    <button type="submit">Save</button>
</form>

<script>
document.getElementById('ajax-form').addEventListener('submit', async (e) => {
    e.preventDefault();

    const formData = new FormData(e.target);

    const response = await fetch('{{ url_for("module.save") }}', {
        method: 'POST',
        body: formData,
        headers: {
            'X-CSRF-Token': formData.get('csrf_token')
        }
    });

    if (response.ok) {
        // Handle success
    } else {
        // Handle error
    }
});
</script>
```

### Multi-Operation Page (No Nested Forms)

```html
<!-- Primary Form -->
<form id="edit-form" method="post">
    <input type="hidden" name="csrf_token" value="{{ csrf_token }}">

    <input type="text" name="title" value="{{ item.title }}">
    <textarea name="description">{{ item.description }}</textarea>

    <button type="submit">Save Changes</button>
</form>

<!-- Attachment Upload (JavaScript, not nested form) -->
<div class="card mt-4">
    <div class="card-header">Attachments</div>
    <div class="card-body">
        <ul id="attachment-list">
            {% for att in item.attachments %}
            <li>{{ att.filename }}
                <button type="button"
                        class="btn btn-sm btn-danger"
                        onclick="deleteAttachment({{ att.id }})">
                    Delete
                </button>
            </li>
            {% endfor %}
        </ul>
    </div>
    <div class="card-footer">
        <input type="file" id="new-attachment">
        <button type="button" onclick="uploadAttachment()">Upload</button>
    </div>
</div>

<script>
async function uploadAttachment() {
    const fileInput = document.getElementById('new-attachment');
    if (!fileInput.files[0]) return;

    const formData = new FormData();
    formData.append('file', fileInput.files[0]);
    formData.append('csrf_token', '{{ csrf_token }}');

    const response = await fetch('{{ url_for("module.upload_attachment", id=item.id) }}', {
        method: 'POST',
        body: formData
    });

    if (response.ok) {
        location.reload();  // Refresh to show new attachment
    }
}

async function deleteAttachment(attachmentId) {
    if (!confirm('Delete this attachment?')) return;

    const formData = new FormData();
    formData.append('csrf_token', '{{ csrf_token }}');

    await fetch(`/attachments/${attachmentId}/delete`, {
        method: 'POST',
        body: formData
    });

    location.reload();
}
</script>
```

---

## 4. File Upload Security

### Complete Server-Side Validation

```python
from pathlib import Path
import uuid
import magic
from fastapi import UploadFile, HTTPException

# Whitelist configuration
ALLOWED_EXTENSIONS = {
    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp',  # Images
    '.pdf',  # Documents
    '.doc', '.docx', '.xls', '.xlsx', '.txt', '.csv',  # Office
}

ALLOWED_MIME_TYPES = {
    'image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp',
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'text/plain', 'text/csv',
}

MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB

UPLOAD_BASE = Path("instance/uploads")


async def validate_and_save_upload(
    file: UploadFile,
    entity_type: str,
    entity_id: int
) -> tuple[str, str, int]:
    """
    Validate and save an uploaded file.

    Returns: (original_filename, stored_filename, file_size)
    Raises: HTTPException on validation failure
    """
    # 1. Check filename and extension
    if not file.filename:
        raise HTTPException(400, "No filename provided")

    original_name = file.filename
    ext = Path(original_name).suffix.lower()

    if ext not in ALLOWED_EXTENSIONS:
        raise HTTPException(400, f"File type '{ext}' not allowed")

    # 2. Read and check size
    content = await file.read()
    file_size = len(content)

    if file_size > MAX_FILE_SIZE:
        raise HTTPException(400, f"File too large. Maximum is {MAX_FILE_SIZE // 1024 // 1024}MB")

    if file_size == 0:
        raise HTTPException(400, "Empty file not allowed")

    # 3. Validate MIME type (don't trust Content-Type header)
    detected_mime = magic.from_buffer(content, mime=True)

    if detected_mime not in ALLOWED_MIME_TYPES:
        raise HTTPException(400, f"File type '{detected_mime}' not allowed")

    # 4. Generate safe filename (NEVER use user-provided name)
    stored_name = f"{uuid.uuid4().hex}{ext}"

    # 5. Create directory structure
    upload_dir = UPLOAD_BASE / entity_type / str(entity_id)
    upload_dir.mkdir(parents=True, exist_ok=True)

    # 6. Save file
    file_path = upload_dir / stored_name
    file_path.write_bytes(content)

    return original_name, stored_name, file_size
```

### Serving Uploaded Files Securely

```python
from fastapi.responses import FileResponse
from pathlib import Path

@router.get("/uploads/{entity_type}/{entity_id}/{filename}")
async def serve_upload(
    entity_type: str,
    entity_id: int,
    filename: str,
    request: Request,
    db: Session = Depends(get_db)
):
    # 1. Authenticate
    current_user = get_current_user(request, db)
    if not current_user:
        raise HTTPException(401, "Authentication required")

    # 2. Validate path components (prevent traversal)
    if '..' in filename or '/' in filename or '\\' in filename:
        raise HTTPException(400, "Invalid filename")

    if not entity_type.isalnum():
        raise HTTPException(400, "Invalid entity type")

    # 3. Build path and verify it exists
    file_path = UPLOAD_BASE / entity_type / str(entity_id) / filename

    if not file_path.exists():
        raise HTTPException(404, "File not found")

    # 4. Verify path is within upload directory (extra safety)
    try:
        file_path.resolve().relative_to(UPLOAD_BASE.resolve())
    except ValueError:
        raise HTTPException(400, "Invalid file path")

    # 5. Serve file
    return FileResponse(
        file_path,
        filename=filename,
        media_type="application/octet-stream"
    )
```

---

## 5. Database Query Security

### ORM Patterns (Always Safe)

```python
# Simple queries
user = db.query(User).filter(User.id == user_id).first()
users = db.query(User).filter(User.is_active == True).all()

# Multiple conditions
requests = db.query(Request).filter(
    Request.status == RequestStatus.NEW,
    Request.priority == RequestPriority.HIGH
).all()

# IN clause
statuses = [RequestStatus.NEW, RequestStatus.IN_PROGRESS]
active = db.query(Request).filter(Request.status.in_(statuses)).all()

# LIKE (pattern matching)
matching = db.query(User).filter(User.name.ilike(f"%{search_term}%")).all()

# Joins
results = db.query(Request, User).join(
    User, Request.assigned_to == User.id
).filter(Request.status == RequestStatus.NEW).all()
```

### Parameterized Raw SQL (When Needed)

```python
from sqlalchemy import text

# CORRECT - Parameters are escaped
result = db.execute(
    text("SELECT * FROM users WHERE email = :email AND role = :role"),
    {"email": email, "role": role}
)

# CORRECT - Complex query with parameters
result = db.execute(text("""
    SELECT r.*, u.name as assignee_name
    FROM requests r
    LEFT JOIN users u ON r.assigned_to = u.id
    WHERE r.created_at > :since
    AND r.status IN :statuses
    ORDER BY r.priority DESC
"""), {
    "since": datetime.now() - timedelta(days=30),
    "statuses": tuple(["new", "in_progress"])
})
```

### Dynamic Queries (Whitelist Columns)

```python
# When user can choose sort/filter columns

SORTABLE_COLUMNS = {
    "created_at": Request.created_at,
    "priority": Request.priority,
    "status": Request.status,
    "title": Request.title,
}

FILTERABLE_COLUMNS = {
    "status": Request.status,
    "priority": Request.priority,
    "category": Request.category,
    "assigned_to": Request.assigned_to,
}

def get_requests(
    db: Session,
    sort_by: str = "created_at",
    sort_dir: str = "desc",
    filters: dict = None
):
    query = db.query(Request)

    # Apply filters (whitelist check)
    if filters:
        for key, value in filters.items():
            column = FILTERABLE_COLUMNS.get(key)
            if column is not None:
                query = query.filter(column == value)

    # Apply sort (whitelist check)
    sort_column = SORTABLE_COLUMNS.get(sort_by, Request.created_at)
    if sort_dir == "asc":
        query = query.order_by(sort_column.asc())
    else:
        query = query.order_by(sort_column.desc())

    return query.all()
```

---

## 6. Configuration Security

### Pydantic Settings Pattern

```python
# app/config.py
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # Required - app won't start without these
    SECRET_KEY: str

    # With defaults
    HOST: str = "0.0.0.0"
    PORT: int = 8008
    DEBUG: bool = False
    LOG_LEVEL: str = "INFO"

    # Database
    DATABASE_URL: str = "sqlite:///instance/app.db"

    # Optional features
    SMTP_ENABLED: bool = False
    SMTP_HOST: str = ""
    SMTP_PORT: int = 587
    SMTP_USER: str = ""
    SMTP_PASSWORD: str = ""  # Sensitive

    # OAuth
    GOOGLE_CLIENT_ID: str = ""
    GOOGLE_CLIENT_SECRET: str = ""  # Sensitive
    GOOGLE_ALLOWED_DOMAIN: str = ""

    class Config:
        env_file = ".env"
        extra = "ignore"  # Ignore unknown env vars

# Single instance
settings = Settings()
```

### Sensitive Settings Encryption

```python
# For settings stored in database
from cryptography.fernet import Fernet
import base64
import hashlib

SENSITIVE_SETTINGS = [
    "smtp.password",
    "google.client_secret",
    "calendar.service_account_key",
    "api_keys.*",  # Pattern match
]

def get_encryption_key() -> bytes:
    """Derive encryption key from SECRET_KEY."""
    return base64.urlsafe_b64encode(
        hashlib.sha256(settings.SECRET_KEY.encode()).digest()
    )

def encrypt_sensitive(value: str) -> str:
    """Encrypt a sensitive value."""
    f = Fernet(get_encryption_key())
    return f.encrypt(value.encode()).decode()

def decrypt_sensitive(encrypted: str) -> str:
    """Decrypt a sensitive value."""
    f = Fernet(get_encryption_key())
    return f.decrypt(encrypted.encode()).decode()

def is_sensitive_setting(key: str) -> bool:
    """Check if a setting key is sensitive."""
    for pattern in SENSITIVE_SETTINGS:
        if pattern.endswith('*'):
            if key.startswith(pattern[:-1]):
                return True
        elif key == pattern:
            return True
    return False
```

### .env.example Template

```ini
# ============================================
# UCC-PMS Configuration
# ============================================
# Copy this file to .env and fill in values
# NEVER commit .env to version control

# ============================================
# REQUIRED - Generate secure values
# ============================================
SECRET_KEY=generate-a-64-char-random-string-here

# ============================================
# Server Settings
# ============================================
HOST=0.0.0.0
PORT=8008
DEBUG=false
LOG_LEVEL=INFO
BASE_URL=http://localhost:8008

# ============================================
# Database
# ============================================
DATABASE_URL=sqlite:///instance/ucc_pms.db

# ============================================
# Google OAuth (Required for staff login)
# ============================================
GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-client-secret
GOOGLE_ALLOWED_DOMAIN=your-domain.org

# ============================================
# Email (Optional)
# ============================================
SMTP_ENABLED=false
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=
# SMTP_PASSWORD=  # Set in production, not here
SMTP_FROM_EMAIL=noreply@your-domain.org
SMTP_FROM_NAME=Your App Name
SMTP_USE_TLS=true
```

---

## Security Audit Checklist

Before deploying, verify:

```
Authentication
[ ] All /admin/* routes check authentication
[ ] Role checks where needed
[ ] Session timeout configured
[ ] Secure cookie flags set

Templates
[ ] No |safe on user content
[ ] tojson used for JS variables
[ ] All forms have CSRF tokens

Forms
[ ] No nested forms
[ ] File uploads have enctype
[ ] Server-side validation exists

Database
[ ] All queries use ORM or parameterization
[ ] No f-strings or % formatting in SQL

File Uploads
[ ] Extension whitelist enforced
[ ] MIME type validated
[ ] Size limits enforced
[ ] UUID filenames used

Configuration
[ ] .env not in repository
[ ] .env.example has no real secrets
[ ] Sensitive settings encrypted in DB
[ ] No hardcoded secrets in code
```
